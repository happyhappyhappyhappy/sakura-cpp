{
	// Place your sakura-cpp ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"yamanaka header snippet": {
		"prefix": "yamaheader_old",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"using ll=long long;",
			"#define COUT(x) cout<<#x<< \" = \" <<(x)<< \" (L\" <<__LINE__<< \")\" <<\"\\n\" << flush",
			"#define debug(...) fprintf(stderr,__VA_ARGS__)",
			"template<class XXX> void chmin(XXX &x,XXX y){",
            "    if(x > y){",
            "        x = y;",
            "    }",
            "}"
		],
		"description": "ヘッダー宣言をする(中古)"
		},
		"山中 初期化": {
			"prefix": "yamaini",
			"body": [
			  "void initial(void){",
			  "    ios_base::sync_with_stdio(false);",
			  "    cin.tie(nullptr);",
			  "    cout.tie(nullptr);",
			  "}"
			],
			"description": "出入力等の初期設定"

		},
		"山中用のmainひな形": {
			"prefix": "yamamain",
			"body": [
			  "int main(void){",
			  "\tinitial();",
			  "\treturn 0;",
			  "}",
			  ""
			],
			"description": "山中用のmainひな形"
		  },
		  "簡単なサンプルを使うためのスニペット": {
			"prefix": "yamasimple",
			"body": [
			  "#include<bits/stdc++.h>",
			  "using namespace std;",
			  "using ll=long long;",
			  "#define COUT(x) cout<<#x<< \" = \" <<(x)<< \" (L\" <<__LINE__<< \")\" <<\"\\n\" << flush",
			  "#define debug(...) fprintf(stderr,__VA_ARGS__)",
			  "template<class XXX> void chmin(XXX &x,XXX y){",
			  "    if(x > y){",
			  "        x = y;",
			  "    }",
			  "}",
			  "",
			  "int main(void){",
			  "",
			  "    return 0;",
			  "}"
			],
			"description": "簡単なサンプルを使うためのスニペット"
		  },
		  "改ヘッダー宣言": {
			"prefix": "yamaheader",
			"body": [
			  "#include<bits/stdc++.h>",
			  "#ifdef LOCAL",
			  "#include\"/wrk/sakura-cpp/comp_pro/debug.h\"",
			  "#include\"/wrk/sakura-cpp/comp_pro/t_debug.h\"",
			  "#include\"/wrk/sakura-cpp/lib/dump.hpp\"",
			  "#else",
			  "#define debug(...) 42",
			  "#define debug2(...) 42",
			  "#define debugt(...) 42",
			  "#define to_string(...) 42",
			  "#define debug_out(...) 42",
			  "#endif",
			  "using namespace std;",
			  "using ll=long long;",
			  "const double pi = 3.141592653589793238;",
			  "const int yamaMAX_INT = 1 << 29;",
			  "const ll yamaMAX_LL = 1LL << 58;",
			],
			"description": "改ヘッダー宣言"
		  },
			"山中のC++スニペット全部": {
				"prefix": "yamacppall",
				"body": [
				"#include<bits/stdc++.h>",
				"#ifdef LOCAL",
				"#include\"/wrk/sakura-cpp/comp_pro/debug.h\"",
				"#include\"/wrk/sakura-cpp/comp_pro/t_debug.h\"",
				"#include\"/wrk/sakura-cpp/lib/dump.hpp\"",
				"#else",
				"#define debug(...) 42",
				"#define debug2(...) 42",
				"#define debugt(...) 42",
				"#define to_string(...) 42",
				"#define debug_out(...) 42",
				"#endif",
				"using namespace std;",
				"using ll=long long;",
				"const double pi = 3.141592653589793238;",
				"const int yamaMAX_INT = 1 << 29;",
				"const ll yamaMAX_LL = 1LL << 60;",
				"",
				"void initial(void){",
				"    ios_base::sync_with_stdio(false);",
				"    cin.tie(nullptr);",
				"    cout.tie(nullptr);",
				"}",
				"int main(void){",
				"    initial();",
				"    return 0;",
				"}"
				],
				"description": "山中のC++スニペット全部20230604"
			},
			"chmix書式": {
				"prefix": "yamachmix",
				"body": [
				  "  template<class XXX> void chmin(XXX &x,XXX y){",
				  "    if(x > y){",
				  "        x = y;",
				  "    }",
				  "}"
				],
				"description": "chmix書式"
			  },
			  "ACLの遅延セグメント簡略": {
				"prefix": "acllazyseg",
				"body": [
				  "namespace atcoder {",
				  "",
				  "namespace internal {",
				  "",
				  "// @param n `0 <= n`",
				  "// @return minimum non-negative `x` s.t. `n <= 2**x`",
				  "int ceil_pow2(int n) {",
				  "    int x = 0;",
				  "    while ((1U << x) < (unsigned int)(n)) x++;",
				  "    return x;",
				  "}",
				  "",
				  "// @param n `1 <= n`",
				  "// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`",
				  "int bsf(unsigned int n) {",
				  "#ifdef _MSC_VER",
				  "    unsigned long index;",
				  "    _BitScanForward(&index, n);",
				  "    return index;",
				  "#else",
				  "    return __builtin_ctz(n);",
				  "#endif",
				  "}",
				  "",
				  "}  // namespace internal",
				  "",
				  "}  // namespace atcoder",
				  "",
				  "namespace atcoder {",
				  "",
				  "template <class S,",
				  "          S (*op)(S, S),",
				  "          S (*e)(),",
				  "          class F,",
				  "          S (*mapping)(F, S),",
				  "          F (*composition)(F, F),",
				  "          F (*id)()>",
				  "struct lazy_segtree {",
				  "  public:",
				  "    lazy_segtree() : lazy_segtree(0) {}",
				  "    lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
				  "    lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {",
				  "        log = internal::ceil_pow2(_n);",
				  "        size = 1 << log;",
				  "        d = std::vector<S>(2 * size, e());",
				  "        lz = std::vector<F>(size, id());",
				  "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
				  "        for (int i = size - 1; i >= 1; i--) {",
				  "            update(i);",
				  "        }",
				  "    }",
				  "",
				  "    void set(int p, S x) {",
				  "        assert(0 <= p && p < _n);",
				  "        p += size;",
				  "        for (int i = log; i >= 1; i--) push(p >> i);",
				  "        d[p] = x;",
				  "        for (int i = 1; i <= log; i++) update(p >> i);",
				  "    }",
				  "",
				  "    S get(int p) {",
				  "        assert(0 <= p && p < _n);",
				  "        p += size;",
				  "        for (int i = log; i >= 1; i--) push(p >> i);",
				  "        return d[p];",
				  "    }",
				  "",
				  "    S prod(int l, int r) {",
				  "        assert(0 <= l && l <= r && r <= _n);",
				  "        if (l == r) return e();",
				  "",
				  "        l += size;",
				  "        r += size;",
				  "",
				  "        for (int i = log; i >= 1; i--) {",
				  "            if (((l >> i) << i) != l) push(l >> i);",
				  "            if (((r >> i) << i) != r) push(r >> i);",
				  "        }",
				  "",
				  "        S sml = e(), smr = e();",
				  "        while (l < r) {",
				  "            if (l & 1) sml = op(sml, d[l++]);",
				  "            if (r & 1) smr = op(d[--r], smr);",
				  "            l >>= 1;",
				  "            r >>= 1;",
				  "        }",
				  "",
				  "        return op(sml, smr);",
				  "    }",
				  "",
				  "    S all_prod() { return d[1]; }",
				  "",
				  "    void apply(int p, F f) {",
				  "        assert(0 <= p && p < _n);",
				  "        p += size;",
				  "        for (int i = log; i >= 1; i--) push(p >> i);",
				  "        d[p] = mapping(f, d[p]);",
				  "        for (int i = 1; i <= log; i++) update(p >> i);",
				  "    }",
				  "    void apply(int l, int r, F f) {",
				  "        assert(0 <= l && l <= r && r <= _n);",
				  "        if (l == r) return;",
				  "",
				  "        l += size;",
				  "        r += size;",
				  "",
				  "        for (int i = log; i >= 1; i--) {",
				  "            if (((l >> i) << i) != l) push(l >> i);",
				  "            if (((r >> i) << i) != r) push((r - 1) >> i);",
				  "        }",
				  "",
				  "        {",
				  "            int l2 = l, r2 = r;",
				  "            while (l < r) {",
				  "                if (l & 1) all_apply(l++, f);",
				  "                if (r & 1) all_apply(--r, f);",
				  "                l >>= 1;",
				  "                r >>= 1;",
				  "            }",
				  "            l = l2;",
				  "            r = r2;",
				  "        }",
				  "",
				  "        for (int i = 1; i <= log; i++) {",
				  "            if (((l >> i) << i) != l) update(l >> i);",
				  "            if (((r >> i) << i) != r) update((r - 1) >> i);",
				  "        }",
				  "    }",
				  "",
				  "    template <bool (*g)(S)> int max_right(int l) {",
				  "        return max_right(l, [](S x) { return g(x); });",
				  "    }",
				  "    template <class G> int max_right(int l, G g) {",
				  "        assert(0 <= l && l <= _n);",
				  "        assert(g(e()));",
				  "        if (l == _n) return _n;",
				  "        l += size;",
				  "        for (int i = log; i >= 1; i--) push(l >> i);",
				  "        S sm = e();",
				  "        do {",
				  "            while (l % 2 == 0) l >>= 1;",
				  "            if (!g(op(sm, d[l]))) {",
				  "                while (l < size) {",
				  "                    push(l);",
				  "                    l = (2 * l);",
				  "                    if (g(op(sm, d[l]))) {",
				  "                        sm = op(sm, d[l]);",
				  "                        l++;",
				  "                    }",
				  "                }",
				  "                return l - size;",
				  "            }",
				  "            sm = op(sm, d[l]);",
				  "            l++;",
				  "        } while ((l & -l) != l);",
				  "        return _n;",
				  "    }",
				  "",
				  "    template <bool (*g)(S)> int min_left(int r) {",
				  "        return min_left(r, [](S x) { return g(x); });",
				  "    }",
				  "    template <class G> int min_left(int r, G g) {",
				  "        assert(0 <= r && r <= _n);",
				  "        assert(g(e()));",
				  "        if (r == 0) return 0;",
				  "        r += size;",
				  "        for (int i = log; i >= 1; i--) push((r - 1) >> i);",
				  "        S sm = e();",
				  "        do {",
				  "            r--;",
				  "            while (r > 1 && (r % 2)) r >>= 1;",
				  "            if (!g(op(d[r], sm))) {",
				  "                while (r < size) {",
				  "                    push(r);",
				  "                    r = (2 * r + 1);",
				  "                    if (g(op(d[r], sm))) {",
				  "                        sm = op(d[r], sm);",
				  "                        r--;",
				  "                    }",
				  "                }",
				  "                return r + 1 - size;",
				  "            }",
				  "            sm = op(d[r], sm);",
				  "        } while ((r & -r) != r);",
				  "        return 0;",
				  "    }",
				  "",
				  "  private:",
				  "    int _n, size, log;",
				  "    std::vector<S> d;",
				  "    std::vector<F> lz;",
				  "",
				  "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
				  "    void all_apply(int k, F f) {",
				  "        d[k] = mapping(f, d[k]);",
				  "        if (k < size) lz[k] = composition(f, lz[k]);",
				  "    }",
				  "    void push(int k) {",
				  "        all_apply(2 * k, lz[k]);",
				  "        all_apply(2 * k + 1, lz[k]);",
				  "        lz[k] = id();",
				  "    }",
				  "};",
				  "",
				  "}  // namespace atcoder",
				  ""
				],
				"description": "ACLの遅延セグメント部分"
			  }
}
