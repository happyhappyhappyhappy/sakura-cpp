ABC 119 解説

出題・解説: @evima0

2019 年 2 月 24 日

A: Still TBD

正解までの道のりを細かく分割すると次の通りです。

1. 標準入力から文字列 s を受け取る。(または、別の何らかの形で入力を受け取る。)

2. s が表す日付が 2019/04/30 以前であるか判定し、答えとなる文字列 Heisei または TBD を得る。

3. 得た文字列を標準出力に出力する。

手順 1, 3 については practice contest 問題 A の言語別サンプルコードが参考になります。手順 2 につい

ては、まず if 文などの何らかの条件分岐を行う機構を用いる必要があります。それに加えて、s と文字列

2019/04/30 を辞書式の順序で直接比較するのが一つの手です。文字列を辞書式順序で比較する機能は現代の

多くの言語に標準で実装されており、「自前」で実装する必要はありません。Python3 での実装例を示します。

1 S = input()

2 print((cid:13)Heisei(cid:13) if S <= (cid:13)2019/04/30(cid:13) else (cid:13)TBD(cid:13))

言語によっては、入力をはじめから整数と文字の並びとして受け取り、「月」の部分が 4 以下であるか否か

を判定するという方針も大いに考えられます。C++ での実装例を示します。

1 #include <iostream>

2 using namespace std;

3 int main(){

int y, m, d;

char c1, c2;

cin >> y >> c1 >> m >> c2 >> d;

cout << (m <= 4 ? "Heisei" : "TBD") << endl;

4

5

6

7

8 }

1

B: Digital Gifts

親戚の人数が 2 人、3 人などと固定されていれば問題 A と大差ありませんが、実際の親戚の人数 N は 2

以上 10 以下と固定されておらず、それに対応するために何らかの「ループ機構」を使うことになります。そ

の代表例が for 文で、この問題でも for 文を使うのが素直でしょう。以下、プログラムで答えを求めるための

機械的な手順を述べます。

まず標準入力から N の値を読み込み、ans という値を宣言して 0 で初期化します。そして次に述べる処
理を N 回繰り返すと、最終的に ans に求めたい値が入ります。i 回目の処理 (1 (cid:20) i (cid:20) N ) は次の通りです:
「標準入力から小数 xi (整数も小数の一種と考えられる) と文字列 ui を読み込む。ui = JPY なら ans に xi
を足す。ui = BTC なら ans に xi (cid:2) 380000:0 を足す」。

これを Python3 で実装したコードが以下です。

1 N = int(input())

2 rate = 380000.0

3 ans = 0.0

4 for i in range(N):

5

6

7

x, u = input().split()

x = float(x)

ans += x * rate if u == (cid:13)BTC(cid:13) else x

8 print((cid:13){:.11f}(cid:13).format(ans))

なお、小数を出力する際は基本的に桁数を多めに (最低でも 10 桁) 持たせることを勧めます。言語と問題

によっては、小数を出力する際の標準の桁数に頼ると精度が足りないことがあるためです。

2

C: Synthetic Kadomatsu

竹の数は 8 本までと少ないですが、それでも三種類の魔法による行動パターンの総数は極めて多いです。

しかし、足し算の結果は順序を入れ替えても変わらないため、例えば「竹 X に延長魔法→竹 Y に延長魔法

→竹 X; Y に合成魔法を使用して竹 XY とする→竹 XY に延長魔法」という一連の行動は、「竹 X; Y に合

成魔法を使用して竹 XY とする→竹 XY に延長魔法を 3 回」という一連の行動と同等です。

このように、「以後合成魔法を使用しないような竹に対してのみ延長・縮小魔法を使用する」ような行動パ

ターンのみを考えると、可能な行動パターンを本質的にすべて列挙することが可能になります。

具体的には、竹 1; 2; : : : ; N のそれぞれに対し、その竹の扱いは本質的には次の 4 通りに限られます:「長さ

A の竹の \材料" とする」「長さ B の竹の材料とする」「長さ C の竹の材料とする」「使わない」。この合計
4N 通りの竹の扱い方をすべて試行します (最大で 48 = 65536 通りで、この数は十分現実的です)。

ただし、\無" に対して延長魔法を使って竹を得ることはできないことに注意します。すなわち、「長さ A

の竹の材料」「長さ B の竹の材料」「長さ C の竹の材料」がそれぞれ一本以上必要で、これを満たさない竹の

扱い方は棄却します。

上記の条件を満たす竹の扱い方に対しては、その場合の「長さ A の竹の材料」をすべて合成して竹を得て、

延長魔法と縮小魔法のうち適切な方を適切な回数だけ使って長さ A の竹を得るためのコストを計算します。

長さ B; C の竹についても同様に得るためのコストを計算して合計すれば、その竹の扱い方で達成できる最小
のコストを計算できます。以上を 4N 通りすべての竹の扱い方に対して行って得られた最小値が答えです。

1 N, A, B, C = map(int, input().split())

2 l = [int(input()) for i in range(N)]

3 INF = 10 ** 9

4

5 def dfs(cur, a, b, c):

if cur == N:

return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF

ret0 = dfs(cur + 1, a, b, c)

ret1 = dfs(cur + 1, a + l[cur], b, c) + 10

ret2 = dfs(cur + 1, a, b + l[cur], c) + 10

ret3 = dfs(cur + 1, a, b, c + l[cur]) + 10

return min(ret0, ret1, ret2, ret3)

6

7

8

9

10

11

12

13

14 print(dfs(0, 0, 0, 0))

3

D: Lazy Faith

一つの問い xi について考えましょう。地点 xi より西にある神社のうち最も東にある神社を sa、xi より東
にある神社のうち最も西にある神社を sb とします。もとの設定のままでは神社 sa; sb のいずれかが存在しな
い可能性がありますが、道路のはるか西とはるか東、訪れる価値がないような位置 (例えば、道路の西端から
1018 メートル西と 1018 メートル東) にも神社があるとすると神社 sa; sb はどちらも必ず存在します。

このとき、道路上に sa; sb 以外の神社は存在しないとしても答えは変わりません。なぜなら、もしその他の
神社 so を訪れることがあれば、その過程ですでに sa; sb のいずれかを通過しているはずで、so をあえて訪れ
る必要はないためです。同様に寺 tc; td を定義すると、それら以外の寺は存在しないとしても答えは変わりま
せん。よって、sa; sb; tc; td のうちどれをどの順に訪れるかの選択 8 通り*1をすべて試せば答えが求まります。

あとは、sa; sb; tc; td をどのように高速に求めるかが課題です。b が求められれば、a = b (cid:0) 1 であり c; d も

同様に求められるため、以下では b を求めることを考えます。

b をより数学的に定義すると「sj > xi であるような最小の整数 j」となります (s1; : : : ; sA がはじめから昇
順に並んでいることに注意)。このような値を高速に求めるアルゴリズムに 二分探索 (リンク先は Wikipedia
の同名の記事) があり、現代の多くの言語に標準で実装されています。これを用いると、⌈log2(A + 2)⌉ ステッ
プ*2の演算で b を求めることができ、10 万個の問いに対しても十分高速です。*3

1 import bisect

2 A, B, Q = map(int, input().split())

3 INF = 10 ** 18

4 s = [-INF] + [int(input()) for i in range(A)] + [INF]

5 t = [-INF] + [int(input()) for i in range(B)] + [INF]

6 for q in range(Q):

7

8

9

10

11

12

13

14

x = int(input())

b, d = bisect.bisect_right(s, x), bisect.bisect_right(t, x)

res = INF

for S in [s[b - 1], s[b]]:

for T in [t[d - 1], t[d]]:

d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)

res = min(res, d1, d2)

print(res)

*1 sa ! tc; sa ! td; sb ! tc; sb ! td とこれらの逆順。これらの中には通り過ぎた寺社に戻ってくるような無意味な歩き方もあり

ますが、最適解を求める上で害はありません

*2 ⌈x⌉ は x 以上の最小の整数です。なお、数式中の \+2" は西の果てと東の果てに足した神社に対応します
*3 ただし \遅い" 言語ではあまり余裕がなく、上記のコードも最適化が甘くかろうじて間に合う程度です

4


